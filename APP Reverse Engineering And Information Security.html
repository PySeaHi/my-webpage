
<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APP逆向工程技术详解：抓包、参数分析与防护绕过</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.5.0/mermaid.min.js"></script>
    <style>
        :root {
            --primary: #1e3a5f;
            --secondary: #2c5282;
            --accent: #4299e1;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --bg-primary: #ffffff;
            --bg-secondary: #f7fafc;
            --border: #e2e8f0;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            background-color: var(--bg-primary);
        }
        
        .serif {
            font-family: 'Playfair Display', serif;
        }
        
        .toc-fixed {
            position: fixed;
            top: 0;
            left: 0;
            width: 280px;
            height: 100vh;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            overflow-y: auto;
            z-index: 1000;
            padding: 2rem 1.5rem;
            box-shadow: 4px 0 20px rgba(0,0,0,0.1);
        }
        
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
        }
        
        .hero-section {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            position: relative;
            overflow: hidden;
        }
        
        .hero-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            align-items: center;
            min-height: 70vh;
        }
        
        .hero-title {
            font-size: 3.5rem;
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .hero-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: 2rem;
        }
        
        .hero-highlights {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        
        .highlight-card {
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .highlight-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 2rem;
            color: var(--primary);
            border-bottom: 3px solid var(--accent);
            padding-bottom: 0.5rem;
        }
        
        .subsection-title {
            font-size: 1.75rem;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            color: var(--secondary);
        }
        
        .content-block {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border);
        }
        
        .method-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--accent);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .table-container {
            overflow-x: auto;
            margin: 2rem 0;
        }
        
        .custom-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .custom-table th {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }
        
        .custom-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }
        
        .custom-table tr:nth-child(even) {
            background: var(--bg-secondary);
        }
        
        .citation {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            text-decoration: none;
            margin: 0 0.2rem;
            transition: background 0.3s ease;
        }
        
        .citation:hover {
            background: var(--secondary);
            color: white;
        }
        
        .toc-link {
            display: block;
            color: rgba(255,255,255,0.8);
            text-decoration: none;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: color 0.3s ease;
        }
        
        .toc-link:hover, .toc-link.active {
            color: white;
            background: rgba(255,255,255,0.1);
            padding-left: 0.5rem;
            border-radius: 4px;
        }
        
        .toc-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .tech-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .tech-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border);
            transition: transform 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .tech-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }
        
        .tech-card:hover::before {
            width: 8px;
        }
        
        .tech-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 1024px) {
            .toc-fixed {
                display: none;
            }
            .main-content {
                margin-left: 0;
            }
            .hero-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Responsive adjustments for small screens */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 2.5rem;
            }
            .hero-subtitle {
                font-size: 1rem;
            }
            .hero-highlights {
                grid-template-columns: 1fr;
            }
            .px-8 {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            .mermaid-control-btn:not(.reset-zoom) {
                display: none;
            }
            .mermaid-controls {
                top: auto;
                bottom: 15px;
                right: 15px;
            }
        }
        
        .pull-quote {
            font-size: 1.25rem;
            font-style: italic;
            color: var(--secondary);
            border-left: 4px solid var(--accent);
            padding-left: 1.5rem;
            margin: 2rem 0;
            background: rgba(66, 153, 225, 0.05);
            padding: 1.5rem;
            border-radius: 8px;
        }
        
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        /* Mermaid diagram styling */
        .mermaid-container {
            display: flex;
            justify-content: center;
            min-height: 300px;
            max-height: 800px;
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }

        .mermaid-container .mermaid {
            width: 100%;
            max-width: 100%;
            height: 100%;
            cursor: grab;
            transition: transform 0.3s ease;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .mermaid-container .mermaid svg {
            max-width: 100%;
            height: 100%;
            display: block;
            margin: 0 auto;
        }

        .mermaid-container .mermaid:active {
            cursor: grabbing;
        }

        .mermaid-container.zoomed .mermaid {
            height: 100%;
            width: 100%;
            cursor: grab;
        }

        .mermaid-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .mermaid-control-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #374151;
            font-size: 14px;
            min-width: 36px;
            height: 36px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mermaid-control-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateY(-1px);
        }

        .mermaid-control-btn:active {
            transform: scale(0.95);
        }
        
        /* Enhanced mermaid styling for better contrast and unified appearance */
        .mermaid svg {
            max-width: 100% !important;
            height: auto !important;
            font-family: 'Inter', sans-serif !important;
            background-color: white !important;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        /* Node styling with better contrast for different colors */
        .mermaid .node rect,
        .mermaid .node circle,
        .mermaid .node ellipse,
        .mermaid .node polygon {
            fill: white !important;
            stroke: var(--primary) !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        /* Different node colors with proper contrast */
        .mermaid .node:nth-child(4n+1) rect,
        .mermaid .node:nth-child(4n+1) circle,
        .mermaid .node:nth-child(4n+1) ellipse,
        .mermaid .node:nth-child(4n+1) polygon {
            fill: #e3f2fd !important;
            stroke: #1976d2 !important;
        }
        
        .mermaid .node:nth-child(4n+2) rect,
        .mermaid .node:nth-child(4n+2) circle,
        .mermaid .node:nth-child(4n+2) ellipse,
        .mermaid .node:nth-child(4n+2) polygon {
            fill: #f3e5f5 !important;
            stroke: #7b1fa2 !important;
        }
        
        .mermaid .node:nth-child(4n+3) rect,
        .mermaid .node:nth-child(4n+3) circle,
        .mermaid .node:nth-child(4n+3) ellipse,
        .mermaid .node:nth-child(4n+3) polygon {
            fill: #e8f5e8 !important;
            stroke: #388e3c !important;
        }
        
        .mermaid .node:nth-child(4n+4) rect,
        .mermaid .node:nth-child(4n+4) circle,
        .mermaid .node:nth-child(4n+4) ellipse,
        .mermaid .node:nth-child(4n+4) polygon {
            fill: #fff3e0 !important;
            stroke: #f57c00 !important;
        }
        
        /* Special styling for start/end nodes */
        .mermaid .node:first-child rect,
        .mermaid .node:first-child circle,
        .mermaid .node:first-child ellipse,
        .mermaid .node:first-child polygon,
        .mermaid .node:last-child rect,
        .mermaid .node:last-child circle,
        .mermaid .node:last-child ellipse,
        .mermaid .node:last-child polygon {
            fill: #fce4ec !important;
            stroke: #c2185b !important;
        }
        
        /* Text styling with high contrast */
        .mermaid .node .label,
        .mermaid .nodeLabel {
            color: var(--text-primary) !important;
            font-weight: 600 !important;
            font-size: 13px !important;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            line-height: 1.4;
        }
        
        /* Edge styling */
        .mermaid .edgePath .path {
            stroke: var(--secondary) !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .mermaid .edgeLabel {
            background-color: white !important;
            color: var(--text-primary) !important;
            font-weight: 600 !important;
            font-size: 12px !important;
            padding: 6px 10px !important;
            border-radius: 6px !important;
            border: 1px solid var(--border) !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }
        
        /* Decision node special styling */
        .mermaid .node.decision rect,
        .mermaid .node.decision polygon {
            fill: #fff8e1 !important;
            stroke: #ffa000 !important;
            stroke-width: 2px !important;
        }
        
        .mermaid .node.decision .label {
            color: #e65100 !important;
            font-weight: 700 !important;
        }
        
        /* Cluster styling */
        .mermaid .cluster rect {
            fill: rgba(66, 153, 225, 0.05) !important;
            stroke: var(--accent) !important;
            stroke-width: 1px !important;
            stroke-dasharray: 5,5 !important;
        }
        
        .mermaid .cluster .label {
            color: var(--secondary) !important;
            font-weight: 700 !important;
            font-size: 14px !important;
        }
        
        /* Timeline specific styling */
        .mermaid .section {
            fill: var(--accent) !important;
            opacity: 0.2 !important;
        }
        
        .mermaid .section0, .mermaid .section1, .mermaid .section2, .mermaid .section3 {
            fill-opacity: 0.2 !important;
        }
        
        .mermaid .cScale0 {
            fill: #e3f2fd !important;
        }
        
        .mermaid .cScale1 {
            fill: #f3e5f5 !important;
        }
        
        .mermaid .cScale2 {
            fill: #e8f5e8 !important;
        }
        
        .mermaid .cScale3 {
            fill: #fff3e0 !important;
        }
    </style>
  </head>

  <body>
    <!-- Fixed Table of Contents -->
    <nav class="toc-fixed">
      <div class="toc-title">目录导航</div>
      <a href="#introduction" class="toc-link">引言</a>
      <a href="#packet-capture" class="toc-link">抓包技术</a>
      <a href="#system-proxy" class="toc-link">• 系统代理抓包</a>
      <a href="#client-certificate" class="toc-link">• 客户端证书校验绕过</a>
      <a href="#server-certificate" class="toc-link">• 服务端证书校验绕过</a>
      <a href="#tcp-capture" class="toc-link">• TCP协议抓包</a>
      <a href="#quic-capture" class="toc-link">• QUIC协议抓包</a>
      <a href="#parameter-analysis" class="toc-link">参数逆向分析</a>
      <a href="#java-decompilation" class="toc-link">• Java层反编译</a>
      <a href="#native-decompilation" class="toc-link">• Native层反编译</a>
      <a href="#frida-application" class="toc-link">• Frida动态分析</a>
      <a href="#xposed-framework" class="toc-link">• Xposed框架应用</a>
      <a href="#security-bypass" class="toc-link">防护绕过</a>
      <a href="#detection-bypass" class="toc-link">• 检测机制绕过</a>
      <a href="#unpacking" class="toc-link">• 加壳与脱壳</a>
      <a href="#frida-unpacking" class="toc-link">• Frida动态脱壳</a>
      <a href="#aosp-customization" class="toc-link">• AOSP定制系统</a>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Hero Section -->
      <section class="hero-section">
        <div class="container mx-auto px-8 py-16">
          <div class="hero-grid">
            <div>
              <h1 class="hero-title serif">APP逆向工程核心技术</h1>
              <p class="hero-subtitle">深度解析抓包、参数分析与防护绕过的完整技术体系</p>
              <div class="flex space-x-4">
                <span class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-medium">逆向分析</span>
                <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-medium">安全研究</span>
                <span class="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-sm font-medium">数据采集</span>
              </div>
              <div class="mt-8 flex items-center space-x-4 text-xm text-slate-600">
                  <span><i class="fas fa-calendar-alt mr-2"></i>2025年7月</span>
                  <span><i class="fas fa-book mr-2"></i>结构化学习报告</span>
		              <span><i class="fas fa-user-edit mr-2"></i>Hale Shi</span>
              </div>
            </div>
            <div class="hero-highlights">
              <div class="highlight-card">
                <i class="fas fa-network-wired text-2xl text-blue-600 mb-3"></i>
                <h3 class="font-semibold mb-2">网络抓包</h3>
                <p class="text-sm text-gray-600">全面覆盖HTTP/HTTPS、TCP、QUIC等协议的抓包技术</p>
              </div>
              <div class="highlight-card">
                <i class="fas fa-code text-2xl text-green-600 mb-3"></i>
                <h3 class="font-semibold mb-2">代码逆向</h3>
                <p class="text-sm text-gray-600">Java与Native层的静态分析与动态调试技术</p>
              </div>
              <div class="highlight-card">
                <i class="fas fa-shield-alt text-2xl text-purple-600 mb-3"></i>
                <h3 class="font-semibold mb-2">安全防护</h3>
                <p class="text-sm text-gray-600">证书校验、Root检测、加壳等防护机制的绕过方法</p>
              </div>
              <div class="highlight-card">
                <i class="fas fa-tools text-2xl text-red-600 mb-3"></i>
                <h3 class="font-semibold mb-2">工具实战</h3>
                <p class="text-sm text-gray-600">Frida、Xposed、IDA Pro等工具的高级应用技巧</p>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Introduction -->
      <section id="introduction" class="container mx-auto px-8 py-16">
        <div class="content-block">
          <h2 class="section-title serif">引言</h2>
          <p class="text-lg leading-relaxed mb-6">
            APP逆向工程是一项复杂的技术，涉及网络通信分析、代码逆向、安全防护绕过等多个方面。本文旨在为初中级信息安全人员和爬虫工程师提供一个关于APP逆向工程技术的详解，内容涵盖抓包技术、参数逆向分析方法以及APP安全防护与逆向突破策略。通过掌握这些技术，读者可以更深入地理解APP的运行机制，发现潜在的安全漏洞，或实现特定的数据采集与分析目标。
          </p>

          <div class="pull-quote">
            "在现代移动应用安全分析中，逆向工程技术不仅是理解应用行为的钥匙，更是发现安全漏洞、提升应用防护能力的重要工具。"
          </div>
        </div>
      </section>

      <!-- Packet Capture Section -->
      <section id="packet-capture" class="container mx-auto px-8 py-8">
        <h2 class="section-title serif">1. APP网络通信抓包技术</h2>

        <!-- System Proxy Capture -->
        <div id="system-proxy" class="content-block">
          <h3 class="subsection-title serif">1.1 系统代理抓包与配置</h3>
          <p class="mb-4">
            在APP逆向工程中，<strong>抓包是分析网络通信行为、理解数据交互逻辑的关键步骤</strong>。系统代理抓包是最基础也是最常用的一种方式，通过将移动设备（如Android手机）的网络流量导向PC端的抓包工具（如Charles、Fiddler、Burp Suite、mitmproxy等），实现对HTTP/HTTPS等应用层协议的监控和分析。
            <a href="https://juejin.cn/post/6874903020677791758" class="citation" target="_blank">[3]</a>
            <a href="https://dead.blue/notes/2020/10/android-app-reverse-engineering-1/" class="citation" target="_blank">[483]</a>
          </p>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">代理配置流程</h4>
              <ul class="space-y-2 text-sm">
                <li>• 在PC端设置抓包工具监听特定端口</li>
                <li>• 移动设备Wi-Fi设置中配置代理服务器</li>
                <li>• 安装抓包工具的CA证书</li>
                <li>• 验证HTTPS流量是否可正常捕获</li>
              </ul>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">常见代理检测绕过</h4>
              <ul class="space-y-2 text-sm">
                <li>• 使用iptables强制流量转发</li>
                <li>• 修改Smali代码移除代理检测</li>
                <li>• 使用透明代理工具(Drony)</li>
                <li>• ProxyDroid全局模式</li>
              </ul>
            </div>
          </div>

          <div class="code-block">
            <pre># 使用iptables将特定APP流量转发到透明代理
iptables -t nat -A OUTPUT -p tcp ! -d 127.0.0.1 \
  -m owner --uid-owner &lt;APP_UID&gt; --dport 0:65535 \
  -j DNAT --to-destination 127.0.0.1:&lt;REDSOCKS_PORT&gt;</pre>
          </div>
        </div>

        <!-- Client Certificate Bypass -->
        <div id="client-certificate" class="content-block">
          <h3 class="subsection-title serif">1.2 客户端证书校验绕过方法</h3>
          <p class="mb-4">
            HTTPS协议通过SSL/TLS加密通信内容，保证了数据传输的安全性。然而，<strong>从Android 7.0 (Nougat) 开始，系统默认不再信任用户安装的CA证书，除非APP显式配置为信任用户证书</strong>。
            <a href="https://www.wangsu.com/news/content/blog/3906" class="citation" target="_blank">[105]</a>
            <a href="https://www.eet-china.com/mp/a163354.html" class="citation" target="_blank">[140]</a>
          </p>

          <div class="table-container">
            <table class="custom-table">
              <thead>
                <tr>
                  <th>方法类别</th>
                  <th>具体方法</th>
                  <th>描述</th>
                  <th>适用场景/备注</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>证书管理</strong></td>
                  <td>将抓包工具CA证书安装到系统信任区</td>
                  <td>在已Root设备上，将CA证书复制到<code>/system/etc/security/cacerts/</code>并设置权限</td>
                  <td>需要Root权限，适用于Android 7.0+</td>
                </tr>
                <tr>
                  <td><strong>证书管理</strong></td>
                  <td>修改APP的<code>network_security_config.xml</code>文件</td>
                  <td>添加<code>&lt;trust-anchors&gt;</code>标签包含<code>&lt;certificates src="user" /&gt;</code></td>
                  <td>需要反编译、修改APK并重打包签名</td>
                </tr>
                <tr>
                  <td><strong>Hook框架</strong></td>
                  <td>使用Xposed框架及其模块</td>
                  <td>Hook APP中负责证书校验的API，使其直接返回验证成功</td>
                  <td>需要安装Xposed框架，主要针对Java层校验</td>
                </tr>
                <tr>
                  <td><strong>Hook框架</strong></td>
                  <td>使用Frida进行Hook</td>
                  <td>编写Frida脚本Hook SSL/TLS相关函数，强制其信任所有证书</td>
                  <td>灵活，可应对Java层和部分Native层校验</td>
                </tr>
                <tr>
                  <td><strong>环境/配置修改</strong></td>
                  <td>降低Android系统版本或使用特定版本模拟器</td>
                  <td>Android 7.0以下系统默认信任用户证书</td>
                  <td>测试环境允许的情况下</td>
                </tr>
              </tbody>
            </table>
            <p class="text-sm text-gray-600 mt-2">Table 1: 客户端证书校验绕过方法总结</p>
          </div>
        </div>

        <!-- Server Certificate Bypass -->
        <div id="server-certificate" class="content-block">
          <h3 class="subsection-title serif">1.3 服务端证书校验绕过技巧</h3>
          <p class="mb-4">
            服务端证书校验，通常指SSL Pinning（证书绑定），是一种增强HTTPS通信安全性的机制。在这种机制下，APP客户端不仅会校验服务端证书是否由受信任的CA签发，还会进一步校验服务端返回的证书是否与APP内置的特定证书完全一致。
            <a href="https://blog.csdn.net/weixin_43845191/article/details/140968996" class="citation" target="_blank">[106]</a>
            <a href="https://boogipop.com/2023/05/29/%5B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%5DFRIDA%20HOOK%EF%BC%9A%E8%84%B1%E5%A3%B3%E3%80%81%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E7%BB%95%E8%BF%87SSL/" class="citation" target="_blank">[144]</a>
          </p>

          <div class="pull-quote">
            当APP启用了SSL Pinning后，使用Charles或Fiddler等工具抓包时，可能会遇到"SSL handshake with client failed"等错误提示，或者APP直接提示网络错误且无法获取数据。
          </div>
        </div>

        <!-- TCP Capture -->
        <div id="tcp-capture" class="content-block">
          <h3 class="subsection-title serif">1.4 TCP协议抓包与分析</h3>
          <p class="mb-4">
            虽然HTTP/HTTPS是APP网络通信中最常见的协议，但许多APP，特别是对性能和实时性要求较高的应用（如游戏、即时通讯、音视频流等），可能会直接使用TCP或UDP等底层协议进行数据传输，或者基于这些协议封装自定义的应用层协议。
            <a href="https://zhuanlan.zhihu.com/p/98955951" class="citation" target="_blank">[12]</a>
          </p>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">tcpdump使用</h4>
              <div class="code-block">
                <pre># 在Android设备上执行
./tcpdump -i any -p -s 0 -w /sdcard/myCapture.pcap

# 常用参数说明
-i any   # 监听所有网络接口
-p       # 不启用混杂模式
-s 0     # 捕获完整数据包
-w       # 写入文件</pre>
              </div>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">Wireshark过滤语法</h4>
              <div class="code-block">
                <pre># 基本过滤
tcp.port == 8888
ip.addr == 192.168.1.100 && tcp

# 高级过滤
tcp contains "keyword"
tcp.flags.syn == 1
tcp.analysis.retransmission</pre>
              </div>
            </div>
          </div>
        </div>

        <!-- QUIC Capture -->
        <div id="quic-capture" class="content-block">
          <h3 class="subsection-title serif">1.5 QUIC协议抓包与挑战</h3>
          <p class="mb-4">
            QUIC（Quick UDP Internet Connections）是一种基于UDP的传输协议，由Google主导开发，旨在减少连接建立和数据传输的延迟，并提供更好的拥塞控制和安全性。QUIC协议默认集成了TLS 1.3加密，其数据包在传输层就已经加密，因此传统的基于TCP的抓包工具无法直接解析其内容。
            <a href="https://www.cnblogs.com/eliwang/p/18023833" class="citation" target="_blank">[15]</a>
          </p>

          <div class="method-card">
            <h4 class="font-semibold mb-2">QUIC抓包技术方案</h4>
            <ul class="space-y-2">
              <li><strong>Wireshark 3.0.0+</strong>：配置SSLKEYLOGFILE环境变量，支持QUIC协议解码</li>
              <li><strong>mitmproxy</strong>：支持HTTPS和QUIC的中间人代理工具</li>
              <li><strong>协议降级</strong>：通过Hook强制应用使用HTTP协议</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Parameter Analysis Section -->
      <section id="parameter-analysis" class="container mx-auto px-8 py-8 bg-gray-50">
        <h2 class="section-title serif">2. APP参数逆向分析方法</h2>

        <!-- Java Decompilation -->
        <div id="java-decompilation" class="content-block">
          <h3 class="subsection-title serif">2.1 Java层代码反编译与分析</h3>
          <p class="mb-4">
            Java层代码是Android APP业务逻辑的主要承载部分，对其进行反编译和分析是APP逆向工程的核心环节。常用的Java反编译工具有<code>Jadx</code>、<code>JEB</code>、<code>Bytecode Viewer</code>等。
            <a href="https://book.crifan.org/books/android_re_decompile_jadx/website/" class="citation" target="_blank">[17]</a>
            <a href="https://developer.aliyun.com/article/1473482" class="citation" target="_blank">[18]</a>
          </p>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">Jadx功能特点</h4>
              <ul class="space-y-2 text-sm">
                <li>• 提供GUI界面和命令行版本</li>
                <li>• 支持多平台（Windows/Linux/macOS）</li>
                <li>• 显示"坏代码"和反混淆功能</li>
                <li>• 强大的搜索功能（字符串、类名、方法名）</li>
                <li>• 解析AndroidManifest.xml和资源文件</li>
              </ul>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">JEB高级功能</h4>
              <ul class="space-y-2 text-sm">
                <li>• 支持多种处理器架构的Native代码反编译</li>
                <li>• 处理混淆代码和重构分析</li>
                <li>• 重建资源和混淆的XML文件</li>
                <li>• 支持Dalvik和Native代码无缝调试</li>
                <li>• 以太坊智能合约反编译支持</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Native Decompilation -->
        <div id="native-decompilation" class="content-block">
          <h3 class="subsection-title serif">2.2 Native层（C/C++）代码反编译与分析</h3>
          <p class="mb-4">
            Android APP除了Java/Kotlin代码外，还可以包含Native代码，通常以<code>.so</code>（共享对象库）文件的形式存在于APK的<code>lib</code>目录下。Native代码通常用于实现高性能计算、调用底层系统功能、复用已有的C/C++库，或者实现核心的加密算法和安全防护逻辑。
          </p>

          <div class="method-card">
            <h4 class="font-semibold mb-2">IDA Pro分析流程</h4>
            <ol class="list-decimal list-inside space-y-2">
              <li>打开目标<code>.so</code>文件，IDA会自动进行初步分析</li>
              <li>识别函数、字符串、导入表、导出表等</li>
              <li>定位目标函数（JNI方法或关键函数）</li>
              <li>分析汇编代码和伪代码（F5功能）</li>
              <li>使用交叉引用和图形视图辅助分析</li>
            </ol>
          </div>

          <div class="pull-quote">
            通过分析伪代码的逻辑流程、变量赋值、函数调用等，可以推断出Native函数的功能和算法实现。动态调试也是分析Native代码的重要手段。
          </div>
        </div>

        <!-- Frida Application -->
        <div id="frida-application" class="content-block">
          <h3 class="subsection-title serif">2.3 动态分析工具：Frida的应用与实战</h3>
          <p class="mb-4">
            Frida是一款强大的动态代码插桩（Dynamic Code Instrumentation）工具，支持Android、iOS、Windows、macOS、Linux等多种平台。它允许通过JavaScript脚本Hook应用程序的函数调用、修改内存数据、调用任意函数等，而无需修改目标应用的原始代码。
            <a href="https://book.crifan.org/books/android_re_dynamic_debug/website/frida_debug_android/" class="citation" target="_blank">[31]</a>
            <a href="https://iiong.com/reinforce-android-applications-for-unpacking-learning/" class="citation" target="_blank">[370]</a>
          </p>

          <div class="code-block">
            <pre>// Frida基本Hook示例
Java.perform(function() {
    var targetClass = Java.use("com.example.TargetClass");
    
    targetClass.targetMethod.implementation = function(param1, param2) {
        console.log("Hook成功！参数:", param1, param2);
        
        // 修改参数或返回值
        var result = this.targetMethod(param1 + " modified", param2);
        return result + " modified";
    };
});</pre>
          </div>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">Frida核心功能</h4>
              <ul class="space-y-2 text-sm">
                <li>• <code>Java.use(className)</code> - 获取Java类引用</li>
                <li>• <code>Interceptor.attach(address, callbacks)</code> - Hook Native函数</li>
                <li>• <code>Java.perform(fn)</code> - 在Java上下文中执行代码</li>
                <li>• <code>Java.choose(className, callbacks)</code> - 枚举已加载的实例</li>
              </ul>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">Objection自动化工具</h4>
              <ul class="space-y-2 text-sm">
                <li>• <code>android sslpinning disable</code> - 自动禁用SSL Pinning</li>
                <li>• <code>android root disable</code> - 绕过Root检测</li>
                <li>• <code>android hooking watch</code> - 监控方法调用</li>
                <li>• 支持非Root设备Frida Gadget注入</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Xposed Framework -->
        <div id="xposed-framework" class="content-block">
          <h3 class="subsection-title serif">2.4 动态分析工具：Xposed框架的应用与绕过</h3>
          <p class="mb-4">
            Xposed框架是一个运行于Android操作系统的动态HOOK框架，它允许在不修改APK文件的情况下，通过安装模块来改变系统和应用的行为。与Frida相比，Xposed主要专注于Java层的HOOK，并且需要修改系统环境。
            <a href="https://blog.csdn.net/weixin_46734340/article/details/117756589" class="citation" target="_blank">[389]</a>
          </p>

          <div class="method-card">
            <h4 class="font-semibold mb-2">Xposed模块开发核心</h4>
            <div class="code-block">
              <pre>public class MyModule implements IXposedHookLoadPackage {
    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {
        if (!lpparam.packageName.equals("target.package")) {
            return;
        }
        
        XposedHelpers.findAndHookMethod("com.example.TargetClass", 
            lpparam.classLoader, "targetMethod", 
            String.class, int.class, new XC_MethodHook() {
                
                @Override
                protected void beforeHookedMethod(MethodHookParam param) {
                    // 方法执行前的处理
                }
                
                @Override
                protected void afterHookedMethod(MethodHookParam param) {
                    // 方法执行后的处理
                }
            });
    }
}</pre>
            </div>
          </div>
        </div>
      </section>

      <!-- Security Bypass Section -->
      <section id="security-bypass" class="container mx-auto px-8 py-8">
        <h2 class="section-title serif">3. APP安全防护与逆向突破</h2>

        <!-- Detection Bypass -->
        <div id="detection-bypass" class="content-block">
          <h3 class="subsection-title serif">3.1 APP常见检测机制与绕过方法</h3>

          <h4 class="font-semibold text-lg mb-3">Root检测与绕过</h4>
          <p class="mb-4">
            Root检测是APP常用的一种安全防护手段，旨在识别运行环境是否具有Root权限。常见的Root检测方法包括检查特定路径下是否存在<code>su</code>等Root管理工具相关的可执行文件、检查系统属性、尝试执行需要Root权限的操作等。
            <a href="https://blog.csdn.net/qq_52380836/article/details/136179658" class="citation" target="_blank">[201]</a>
            <a href="https://www.cnblogs.com/eliwang/p/17950005" class="citation" target="_blank">[208]</a>
          </p>

          <div class="table-container">
            <table class="custom-table">
              <thead>
                <tr>
                  <th>检测点类别</th>
                  <th>具体检测方法</th>
                  <th>应用层Hook绕过思路</th>
                  <th>系统层定制/AOSP修改思路</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Root相关文件检测</strong></td>
                  <td>检查<code>/system/bin/su</code>, <code>/system/xbin/su</code>等路径</td>
                  <td>Hook文件访问函数，返回<code>false</code></td>
                  <td>修改文件系统，移除或重命名<code>su</code>文件</td>
                </tr>
                <tr>
                  <td><strong>Root相关属性检测</strong></td>
                  <td>检查<code>ro.build.tags</code>是否为<code>test-keys</code></td>
                  <td>Hook <code>SystemProperties.get()</code>方法</td>
                  <td>修改<code>build.prop</code>文件，将<code>test-keys</code>改为<code>release-keys</code></td>
                </tr>
                <tr>
                  <td><strong>Root管理应用检测</strong></td>
                  <td>检查已安装应用列表中是否存在SuperSU等包名</td>
                  <td>Hook包管理器相关API，过滤Root管理应用</td>
                  <td>卸载或冻结Root管理应用</td>
                </tr>
                <tr>
                  <td><strong>执行Root命令检测</strong></td>
                  <td>尝试执行<code>su -c whoami</code>等命令</td>
                  <td>Hook <code>Runtime.exec()</code>等方法</td>
                  <td>修改<code>su</code>命令本身，返回非<code>root</code>结果</td>
                </tr>
                <tr>
                  <td><strong>系统指纹检测</strong></td>
                  <td>检查<code>android.os.Build</code>中的<code>FINGERPRINT</code>、<code>TAGS</code>等字段</td>
                  <td>Hook <code>android.os.Build</code>类的相关方法</td>
                  <td>修改AOSP源码中<code>deriveFingerprint()</code>等方法</td>
                </tr>
              </tbody>
            </table>
            <p class="text-sm text-gray-600 mt-2">Table 2: Root检测点及绕过思路</p>
          </div>

          <h4 class="font-semibold text-lg mb-3 mt-8">Xposed与Frida检测绕过</h4>
          <div class="table-container">
            <table class="custom-table">
              <thead>
                <tr>
                  <th>检测点类别</th>
                  <th>具体检测方法</th>
                  <th>应用层Hook/配置绕过思路</th>
                  <th>系统层定制/AOSP修改思路</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Xposed检测</strong></td>
                  <td>检查<code>de.robv.android.xposed.installer</code>等包名</td>
                  <td>使用Xposed隐藏模块（XPrivacyLua）</td>
                  <td>修改包管理器API，过滤Xposed Installer包名</td>
                </tr>
                <tr>
                  <td><strong>Xposed检测</strong></td>
                  <td>检查<code>/system/framework/XposedBridge.jar</code>等文件</td>
                  <td>Hook文件访问函数，返回文件不存在</td>
                  <td>修改文件系统，隐藏Xposed相关文件</td>
                </tr>
                <tr>
                  <td><strong>Frida检测</strong></td>
                  <td>检测<code>frida-server</code>进程名</td>
                  <td>重命名<code>frida-server</code>二进制文件</td>
                  <td>修改进程枚举相关的系统API</td>
                </tr>
                <tr>
                  <td><strong>Frida检测</strong></td>
                  <td>检测默认端口（27042/tcp）是否被监听</td>
                  <td>启动时指定非默认端口</td>
                  <td>修改网络连接状态相关的系统API</td>
                </tr>
              </tbody>
            </table>
            <p class="text-sm text-gray-600 mt-2">Table 3: Xposed与Frida检测点及绕过思路</p>
          </div>
        </div>

        <!-- Unpacking -->
        <div id="unpacking" class="content-block">
          <h3 class="subsection-title serif">3.2 APP加壳（加固）技术与脱壳方法</h3>
          <p class="mb-4">
            APP加壳，也称为APP加固，是一种保护Android应用程序免受逆向工程和恶意篡改的技术。其核心思想是对原始的DEX文件（包含应用的Java代码）和so库文件（包含Native代码）进行加密、混淆、虚拟化等处理。
            <a href="https://whitebird0.github.io/post/Android%E7%B3%BB%E7%BB%9F%E6%B2%99%E7%9B%92%E5%AE%9A%E5%88%B6%E4%B8%93%E9%A2%98.html" class="citation" target="_blank">[203]</a>
            <a href="https://saucer-man.com/android/1000.html" class="citation" target="_blank">[266]</a>
          </p>

          <!-- Mermaid diagram for unpacking process -->
          <div class="mermaid-container">
            <div class="mermaid-controls">
              <button class="mermaid-control-btn zoom-in" title="放大">
                <i class="fas fa-search-plus"></i>
              </button>
              <button class="mermaid-control-btn zoom-out" title="缩小">
                <i class="fas fa-search-minus"></i>
              </button>
              <button class="mermaid-control-btn reset-zoom" title="重置">
                <i class="fas fa-expand-arrows-alt"></i>
              </button>
              <button class="mermaid-control-btn fullscreen" title="全屏查看">
                <i class="fas fa-expand"></i>
              </button>
            </div>
            <div class="mermaid" id="mermaid-diagram">
              graph TD
              A["加密的DEX/So文件"] --> B["壳程序加载"]
              B --> C{"内存中解密?"}
              C -->|是| D["原始代码在内存中"]
              C -->|否| E["继续加密状态"]
              D --> F["Hook关键函数"]
              D --> G["内存Dump"]
              D --> H["定制ROM脱壳"]
              F --> I["获取解密代码"]
              G --> I
              H --> I
              I --> J["分析原始逻辑"]

              style A fill:#ffebee,stroke:#d32f2f,stroke-width:2px,color:#000
              style D fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
              style I fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000
              style J fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
              style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
            </div>
          </div>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">常见加壳技术</h4>
              <ul class="space-y-2 text-sm">
                <li><strong>整体加固（DEX加密）</strong>：壳程序将原始DEX文件整体加密，运行时解密加载</li>
                <li><strong>抽取壳</strong>：将方法体指令抽取出来单独加密，原方法体用NOP填充</li>
                <li><strong>VMP壳</strong>：将代码转换为自定义指令集字节码，内部解释器执行</li>
                <li><strong>so加固</strong>：针对Native库的代码混淆、控制流平坦化、字符串加密</li>
              </ul>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">脱壳方法分类</h4>
              <ul class="space-y-2 text-sm">
                <li><strong>静态脱壳</strong>：分析壳程序解密算法，编写解密脚本</li>
                <li><strong>动态脱壳</strong>：利用APP运行时内存中的数据</li>
                <li><strong>内存Dump</strong>：分析内存布局，找到解密后的DEX/so并提取</li>
                <li><strong>Hook关键函数</strong>：通过Frida/Xposed Hook加载DEX的关键函数</li>
                <li><strong>定制ROM/插桩脱壳</strong>：修改AOSP源码，在虚拟机执行路径插入Dump代码</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Frida Unpacking -->
        <div id="frida-unpacking" class="content-block">
          <h3 class="subsection-title serif">3.3 使用Frida进行动态脱壳</h3>
          <p class="mb-4">
            Frida作为一款强大的动态代码插桩工具，在APP逆向工程中扮演着至关重要的角色，尤其在动态脱壳方面展现出其独特的优势。<strong>FRIDA-DEXDump</strong> 是一款基于Frida的经典Android脱壳工具，由hluwa开发并开源。
            <a href="https://blog.csdn.net/qq_36301061/article/details/143532553" class="citation" target="_blank">[341]</a>
            <a href="https://blog.csdn.net/weixin_38819889/article/details/123880076" class="citation" target="_blank">[344]</a>
          </p>

          <div class="method-card">
            <h4 class="font-semibold mb-2">FRIDA-DEXDump脱壳步骤</h4>
            <ol class="list-decimal list-inside space-y-2">
              <li>确保目标Android设备已root，并安装匹配版本的frida-server</li>
              <li>在PC上安装FRIDA-DEXDump：<code>pip install frida-dexdump</code></li>
              <li>启动目标应用程序</li>
              <li>在PC上运行：<code>frida-dexdump -U -f com.target.app</code></li>
              <li>工具会自动附加到目标进程，搜索并dump内存中的DEX文件</li>
            </ol>
          </div>

          <div class="code-block">
            <pre>// 自定义Frida脱壳脚本示例
Java.perform(function() {
    var dexDump = function() {
        // 搜索内存中的DEX文件特征
        Process.enumerateRanges('r--').forEach(function(range) {
            try {
                var magic = range.base.readCString(4);
                if (magic === 'dex\n') {
                    console.log('Found DEX at:', range.base);
                    
                    // 计算DEX大小
                    var fileSize = range.base.add(0x20).readUInt() * 4;
                    console.log('DEX size:', fileSize);
                    
                    // Dump到文件
                    var dexData = range.base.readByteArray(fileSize);
                    var outPath = '/sdcard/dex_dump_' + range.base + '.dex';
                    var outFile = new File(outPath, 'wb');
                    outFile.write(dexData);
                    outFile.close();
                    
                    console.log('Dumped to:', outPath);
                }
            } catch (e) {
                // 忽略错误
            }
        });
    };
    
    // 延时执行，确保DEX已加载
    setTimeout(dexDump, 3000);
});</pre>
          </div>
        </div>

        <!-- AOSP Customization -->
        <div id="aosp-customization" class="content-block">
          <h3 class="subsection-title serif">3.4 基于AOSP定制系统进行高级逆向</h3>
          <p class="mb-4">
            基于Android Open Source Project (AOSP) 定制Android系统是进行高级APP逆向分析的一种强大手段。通过修改和编译AOSP源码，可以在系统层面实现对APP行为的深度监控和干预，这对于分析复杂的加固方案、绕过强效的检测机制以及进行底层Hook等场景非常有效。
            <a href="https://saucer-man.com/android/1000.html" class="citation" target="_blank">[266]</a>
            <a href="https://whitebird0.github.io/post/Android%E7%B3%BB%E7%BB%9F%E6%B2%99%E7%9B%92%E5%AE%9A%E5%88%B6%E4%B8%93%E9%A2%98.html" class="citation" target="_blank">[270]</a>
          </p>

          <div class="tech-grid">
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">AOSP定制优势</h4>
              <ul class="space-y-2 text-sm">
                <li><strong>隐蔽性强</strong>：系统级修改更难被APP检测</li>
                <li><strong>控制力强</strong>：可深度干预APP运行环境</li>
                <li><strong>稳定性高</strong>：一次修改，长期有效</li>
                <li><strong>功能强大</strong>：可同时实现脱壳、绕过检测等多种功能</li>
              </ul>
            </div>
            <div class="tech-card">
              <h4 class="font-semibold text-lg mb-3">FART脱壳机原理</h4>
              <ul class="space-y-2 text-sm">
                <li>修改ART虚拟机源码</li>
                <li>在类初始化、方法执行时插入Dump代码</li>
                <li>主动调用DEX中的各个函数</li>
                <li>诱使壳解密对应的method指令区域</li>
                <li>自动将内存中的DEX数据dump下来</li>
              </ul>
            </div>
          </div>

          <div class="pull-quote">
            定制AOSP系统进行逆向的优势在于其强大的控制能力和隐蔽性。然而，这种方法的技术门槛较高，需要熟悉Android系统架构、AOSP源码结构和编译流程。
          </div>

          <div class="method-card">
            <h4 class="font-semibold mb-2">AOSP定制绕过检测示例</h4>
            <div class="code-block">
              <pre>// 修改系统属性，去除Root特征
修改 build/core/main.mk:
- BUILD_VERSION_TAGS := release-keys
+ BUILD_VERSION_TAGS := test-keys

修改 system/core/init/property_service.c:
- __system_property_set("ro.secure", "0");
+ __system_property_set("ro.secure", "1");

// 隐藏特定文件访问
修改 libc/bionic/open.cpp:
if (strstr(path, "su") || strstr(path, "magisk")) {
    errno = ENOENT;
    return -1;
}</pre>
            </div>
          </div>
        </div>
      </section>

      <!-- Footer -->
      <footer class="bg-gray-900 text-white py-12">
        <div class="container mx-auto px-8">
          <div class="text-center">
            <p class="text-gray-400 mb-4">本文档提供了APP逆向工程的全面技术指导，适用于安全研究人员和开发人员学习使用</p>
            <p class="text-sm text-gray-500">发布日期：2025年07月27日</p>
          </div>
        </div>
      </footer>
    </main>

    <script>
        // Initialize Mermaid with enhanced configuration
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({ 
                startOnLoad: true,
                theme: 'base',
                themeVariables: {
                    primaryColor: '#ffffff',
                    primaryTextColor: '#2d3748',
                    primaryBorderColor: '#2c5282',
                    lineColor: '#4299e1',
                    secondaryColor: '#f7fafc',
                    tertiaryColor: '#e2e8f0',
                    background: '#ffffff',
                    mainBkg: '#ffffff',
                    secondBkg: '#f7fafc',
                    tertiaryBkg: '#e2e8f0',
                    // Enhanced contrast colors for different node types
                    primaryTextColor: '#2d3748',
                    secondaryTextColor: '#4a5568',
                    tertiaryTextColor: '#718096',
                    // Node colors with good contrast
                    primaryBorderColor: '#1e3a5f',
                    primaryTextColor: '#2d3748',
                    // Error and success colors
                    errorBkgColor: '#fed7d7',
                    errorTextColor: '#c53030',
                    successBkgColor: '#c6f6d5',
                    successTextColor: '#2f855a'
                },
                flowchart: {
                    useMaxWidth: false,
                    htmlLabels: true,
                    curve: 'basis',
                    padding: 20
                },
                sequence: {
                    useMaxWidth: false,
                    padding: 20
                },
                gantt: {
                    useMaxWidth: false,
                    padding: 20
                }
            });
            
            // Initialize mermaid controls after a short delay to allow rendering
            setTimeout(initializeMermaidControls, 1000);
        });

        // Initialize Mermaid Controls for zoom and pan
        function initializeMermaidControls() {
            const containers = document.querySelectorAll('.mermaid-container');

            containers.forEach(container => {
            const mermaidElement = container.querySelector('.mermaid');
            let scale = 1;
            let isDragging = false;
            let startX, startY, translateX = 0, translateY = 0;

            // 触摸相关状态
            let isTouch = false;
            let touchStartTime = 0;
            let initialDistance = 0;
            let initialScale = 1;
            let isPinching = false;

            // Zoom controls
            const zoomInBtn = container.querySelector('.zoom-in');
            const zoomOutBtn = container.querySelector('.zoom-out');
            const resetBtn = container.querySelector('.reset-zoom');
            const fullscreenBtn = container.querySelector('.fullscreen');

            function updateTransform() {
                mermaidElement.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

                if (scale > 1) {
                container.classList.add('zoomed');
                } else {
                container.classList.remove('zoomed');
                }

                mermaidElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                scale = Math.min(scale * 1.25, 4);
                updateTransform();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                scale = Math.max(scale / 1.25, 0.3);
                if (scale <= 1) {
                    translateX = 0;
                    translateY = 0;
                }
                updateTransform();
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
                });
            }

            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                });
            }

            // Mouse Events
            mermaidElement.addEventListener('mousedown', (e) => {
                if (isTouch) return; // 如果是触摸设备，忽略鼠标事件

                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                mermaidElement.style.cursor = 'grabbing';
                updateTransform();
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && !isTouch) {
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                updateTransform();
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging && !isTouch) {
                isDragging = false;
                mermaidElement.style.cursor = 'grab';
                updateTransform();
                }
            });

            document.addEventListener('mouseleave', () => {
                if (isDragging && !isTouch) {
                isDragging = false;
                mermaidElement.style.cursor = 'grab';
                updateTransform();
                }
            });

            // 获取两点之间的距离
            function getTouchDistance(touch1, touch2) {
                return Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
                );
            }

            // Touch Events - 触摸事件处理
            mermaidElement.addEventListener('touchstart', (e) => {
                isTouch = true;
                touchStartTime = Date.now();

                if (e.touches.length === 1) {
                // 单指拖动
                isPinching = false;
                isDragging = true;

                const touch = e.touches[0];
                startX = touch.clientX - translateX;
                startY = touch.clientY - translateY;

                } else if (e.touches.length === 2) {
                // 双指缩放
                isPinching = true;
                isDragging = false;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = getTouchDistance(touch1, touch2);
                initialScale = scale;
                }

                e.preventDefault();
            }, { passive: false });

            mermaidElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging && !isPinching) {
                // 单指拖动
                const touch = e.touches[0];
                translateX = touch.clientX - startX;
                translateY = touch.clientY - startY;
                updateTransform();

                } else if (e.touches.length === 2 && isPinching) {
                // 双指缩放
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = getTouchDistance(touch1, touch2);

                if (initialDistance > 0) {
                    const newScale = Math.min(Math.max(
                    initialScale * (currentDistance / initialDistance),
                    0.3
                    ), 4);
                    scale = newScale;
                    updateTransform();
                }
                }

                e.preventDefault();
            }, { passive: false });

            mermaidElement.addEventListener('touchend', (e) => {
                // 重置状态
                if (e.touches.length === 0) {
                isDragging = false;
                isPinching = false;
                initialDistance = 0;

                // 延迟重置isTouch，避免鼠标事件立即触发
                setTimeout(() => {
                    isTouch = false;
                }, 100);
                } else if (e.touches.length === 1 && isPinching) {
                // 从双指变为单指，切换为拖动模式
                isPinching = false;
                isDragging = true;

                const touch = e.touches[0];
                startX = touch.clientX - translateX;
                startY = touch.clientY - translateY;
                }

                updateTransform();
            });

            mermaidElement.addEventListener('touchcancel', (e) => {
                isDragging = false;
                isPinching = false;
                initialDistance = 0;

                setTimeout(() => {
                isTouch = false;
                }, 100);

                updateTransform();
            });

            // Enhanced wheel zoom with better center point handling
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.min(Math.max(scale * delta, 0.3), 4);

                // Adjust translation to zoom towards center
                if (newScale !== scale) {
                const scaleDiff = newScale / scale;
                translateX = translateX * scaleDiff;
                translateY = translateY * scaleDiff;
                scale = newScale;

                if (scale <= 1) {
                    translateX = 0;
                    translateY = 0;
                }

                updateTransform();
                }
            });

            // Initialize display
            updateTransform();
            });
        }

        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active TOC link highlighting
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('section[id], div[id]');
            const scrollPos = window.scrollY + 100;
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.offsetHeight;
                const sectionId = section.getAttribute('id');
                
                if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
                    document.querySelectorAll('.toc-link').forEach(link => {
                        link.classList.remove('active');
                    });
                    const activeLink = document.querySelector(`a[href="#${sectionId}"]`);
                    if (activeLink) {
                        activeLink.classList.add('active');
                    }
                }
            });
        });

        // Add hover effects to tech cards
        document.querySelectorAll('.tech-card').forEach(card => {
            card.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-5px)';
                this.style.boxShadow = '0 15px 30px rgba(0,0,0,0.1)';
            });
            
            card.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0)';
                this.style.boxShadow = 'none';
            });
        });
    </script>
  </body>

</html>
